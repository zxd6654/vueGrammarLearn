<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    shallowRef()
    ref() 的浅层作用形式。
    和 ref() 不同，浅层 ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。只有对 .value 的访问是响应式的。

    shallowRef() 常常用于对大型数据结构的性能优化或是与外部的状态管理系统集成。

    triggerRef()
    强制触发依赖于一个浅层 ref 的副作用，这通常在对浅引用的内部值进行深度变更后使用。

    customRef()
    创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。

    shallowReactive()
    reactive() 的浅层作用形式。
    和 reactive() 不同，这里没有深层级的转换：一个浅层响应式对象里只有根级别的属性是响应式的。属性的值会被原样存储和暴露，这也意味着值为 ref 的属性不会被自动解包了。

    shallowReadonly()
    readonly() 的浅层作用形式
    和 readonly() 不同，这里没有深层级的转换：只有根层级的属性变为了只读。属性的值都会被原样存储和暴露，这也意味着值为 ref 的属性不会被自动解包了。

    toRaw()
    根据一个 Vue 创建的代理返回其原始对象。

    markRaw()
    将一个对象标记为不可被转为代理。返回该对象本身。

    effectScope()
    创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理。

    getCurrentScope()
    如果有的话，返回当前活跃的 effect 作用域。

    onScopeDispose()
    在当前活跃的 effect 作用域上注册一个处理回调函数。当相关的 effect 作用域停止时会调用这个回调函数。
</body>

</html>