<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    基础实例

    计算属性缓存 vs 方法

    不同之处在于计算属性值会基于其响应式依赖被缓存。
    一个计算属性仅会在其响应式依赖更新时才重新计算。
    这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage
    都会立即返回先前的计算结果，而不用重复执行 getter 函数。

    相比之下，方法调用总是会在重渲染发生时再次执行函数。

    可写计算属性
    get，set

    最佳实践​
    Getter 不应有副作用​
    计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。
    举例来说，不要改变其他状态、在 getter 中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。
    因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用侦听器根据其他响应式状态的变更来创建副作用。

    避免直接修改计算属性值​
    从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。
    更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。
</body>

</html>