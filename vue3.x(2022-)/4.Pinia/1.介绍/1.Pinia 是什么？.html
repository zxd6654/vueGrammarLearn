<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    为什么你应该使用 Pinia？
    Pinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。如果你熟悉组合式 API 的话，你可能会认为可以通过一行简单的 export const state = reactive({}) 来共享一个全局状态。
    对于单页应用来说确实可以，但如果应用在服务器端渲染，这可能会使你的应用暴露出一些安全漏洞。 而如果使用 Pinia，即使在小型单页应用中，你也可以获得如下功能：

    测试工具集
    插件：可通过插件扩展 Pinia 功能
    为 JS 开发者提供适当的 TypeScript 支持以及自动补全功能。
    支持服务端渲染
    Devtools 支持
    追踪 actions、mutations 的时间线
    在组件中展示它们所用到的 Store
    让调试更容易的 Time travel
    热更新
    不必重载页面即可修改 Store
    开发时可保持当前的 State

    基础示例
    官方课程
    为什么取名 Pinia？
    更真实的示例

    对比 Vuex

    与 Vuex 相比，Pinia 不仅提供了一个更简单的 API，也提供了符合组合式 API 风格的 API，最重要的是，搭配 TypeScript 一起使用时有非常可靠的类型推断支持。

    对比 Vuex 3.x/4.x
    Vuex 3.x 只适配 Vue 2，而 Vuex 4.x 是适配 Vue 3 的。

    Pinia API 与 Vuex(<=4) 也有很多不同，即： 
    mutation 已被弃用。它们经常被认为是极其冗余的。它们初衷是带来 devtools 的集成方案，但这已不再是一个问题了。 无需要创建自定义的复杂包装器来支持
        TypeScript，一切都可标注类型，API 的设计方式是尽可能地利用 TS 类型推理。
        无过多的魔法字符串注入，只需要导入函数并调用它们，然后享受自动补全的乐趣就好。 无需要动态添加
        Store，它们默认都是动态的，甚至你可能都不会注意到这点。注意，你仍然可以在任何时候手动使用一个 Store 来注册它，但因为它是自动的，所以你不需要担心它。 不再有嵌套结构的模块。
        你仍然可以通过导入和使用另一个Store 来隐含地嵌套 stores 空间。虽然 Pinia 从设计上提供的是一个扁平的结构，但仍然能够在 Store 之间进行交叉组合。你甚至可以让 Stores 有循环依赖关系。
        不再有可命名的模块。考虑到 Store的扁平架构，Store 的命名取决于它们的定义方式，你甚至可以说所有 Store 都应该命名。
</body>

</html>